%Reserves can be promised from 1000 till 1500kW else it is 0 no less than
%100kWh 
%% ---- Input DATA ---
%clear; clc;
%Tin_Day;
%yalmip('clear')

% --- Load data ---
%Price_data_filteration;
load('JanFeb_Prices.mat');
Price = TT_full.price_values / 1000;% €/kWh

%LoadWeather;
load('weather_hourly.mat');
T_out = Temperature_clean;% °C

%Tin_Day;
load('RCinput.mat');
load('thermal.mat');

% --- Parameters ---
n= length(T_out);          % timesteps
dt= 3600; delta_t = dt/3600; % time [h]
T_initial = 20; T_min = 18; T_max = 23;
COP = 2.5;
Q_int_3   = 500; 
Q_max_3 = 30000;% each floor 2kW max (1000m2)from Q_max file 

S_max3  = 150;  % kWh 
eta_c3 = 0.95; eta_d3 = 0.95;
P_charge_max3 = 5;
Discharge_limit3 = S_max3 / num_f;
P_floor_max3 = Discharge_limit3 / delta_t;
S0_3  = 0;
% --- Market participation---
B  = 8; % buildings
Ns  = 3; % scenarios
pi_s  = [0.3 0.5 0.2]; % ones(Ns,1) / Ns 
% 50% of chance that the actual forecast could happen and the cold case
% could be 30% and warm case could be 20% 
pen_short = 350;    % €/MWh  %300
cap_price = 40;      % €/MW/h %30
SlackPenalty = 1e6;
%% Presolve sanity check
Pel1_building_cap = (num_f * Q_max_3) / (COP*1000) + P_charge_max3;  % kW
Pel_pool_cap = B * Pel1_building_cap;                           % kW
fprintf('Pel1 cap per building ~ %.1f kW; Pooled capacity  ~ %.1f kW\n', ...
        Pel1_building_cap, Pel_pool_cap);
%% Scenario decision variables
T_out_s = cell(Ns,1);
Price_s = cell(Ns,1);
Q_int_s = cell(Ns,1);

for w = 1:Ns
   T_out_s{w} = T_out + 0.5*(w - ceil(Ns/2)); % change in T_out for different Scenarios 
   Price_s{w} = Price .* (1 + 0.05*(w - ceil(Ns/2))); % change in Price for different scenarios 
   Q_int_s{w} = Q_int_3 * ones(n,1);
end

%%  Stage 1 Variables & Constraints
Q_s1 = sdpvar(n+1, num_f);  
T_s1 = sdpvar(n+1, num_f);
S_s1 = sdpvar(n+1, 1); 
Pch1 = sdpvar(n+1, 1);
Pdis1_f = sdpvar(n+1, num_f); 
slk1 = sdpvar(n+1, num_f);
Res_RA = sdpvar(n,1); % reserve commitment
z_res = binvar(n,1);  % binary: 1 if reserve committed at time t
Res_min =1000;%1MW
Res_max=3000;
conStg1=[];
conStg1 = [conStg1;T_s1(1,:) == T_initial, S_s1(1) == S0_3];

for t = 1:n
    total_dis1 = sum(Pdis1_f(t,:)) * delta_t;
    for f = 1:num_f
        a = dt/(C_zone(f)*R_zone(f));
        b = dt/C_zone(f);
        Qstor = Pdis1_f(t,f)*1000;
        conStg1 = [conStg1;
            T_s1(t+1,f) == T_s1(t,f) + a*(T_out(t)-T_s1(t,f)) + b*(Q_s1(t,f) + Q_int_3 + Qstor)];
            conStg1 = [conStg1;0 <= Pdis1_f(t,f) <= P_floor_max3];
            %conStg1 = [conStg1;Pdis1_f(t,f)*delta_t <= Discharge_limit3];
    end
    conStg1 = [conStg1;S_s1(t+1) == S_s1(t) + eta_c3*Pch1(t)*delta_t - total_dis1/eta_d3];
    conStg1 = [conStg1 ;total_dis1 <= S_s1(t)];
end

% --- Electric power (per building, decisions 1..n) ---
Pel1 = (sum(Q_s1(1:n,:),2)/(COP*1000)) + Pch1(1:n);   % kW

% --- Comfort & slack (apply once, not inside loops) ---
conStg1 = [conStg1; ...
  T_s1(2:end,:) + slk1(2:end,:) >= T_min, ...
  T_s1(2:end,:) <= T_max, ...
  0 <= slk1 <= (T_max - T_min), ...
  0 <= S_s1 <= S_max3, 0 <= Q_s1 <= Q_max_3, 0 <= Pch1 <= P_charge_max3];

% --- Storage charging bound (vectorized once over all t) ---
conStg1 = [conStg1; Pch1(1:n)*delta_t <= S_max3 - S_s1(1:n)];

% --- Reserve gating & caps (apply ONCE, outside loops) ---
conStg1 = [conStg1; ...
  0 <= Res_RA <= Res_max, ...         % base bounds
  Res_RA >= Res_min * z_res, ...      % min 1 MW if committed
  Res_RA <= Res_max * z_res, ...      % 0 if not committed
  Res_RA <= B * Pel1];                % physics cap: can’t reduce > you consume

%% ----Stage 2 Variables & Constraints----
Q_s2 = cell(Ns,1); 
T_s2 = cell(Ns,1);
S_s2 = cell(Ns,1);
Pch2 = cell(Ns,1); Pdis2_f = cell(Ns,1);
slk2 = cell(Ns,1);
%r = cell(Ns,1);
sshort = cell(Ns,1); nu = cell(Ns,1);
conRec = cell(Ns,1);

for w = 1:Ns
    Q_s2{w} = sdpvar(n+1, num_f);      T_s2{w} = sdpvar(n+1, num_f);
    S_s2{w} = sdpvar(n+1, 1);          Pch2{w} = sdpvar(n+1, 1);
    Pdis2_f{w} = sdpvar(n+1, num_f); slk2{w} = sdpvar(n+1, num_f);
    %r{w} = sdpvar(n,1);              
    sshort{w} = sdpvar(n,1);% short fall between Reserve in stage 1 and stage 2 
    nu{w} = sdpvar(n,1);% Tail losses in TCVaR

    conRec{w} = [conRec{w};T_s2{w}(1,:) == T_initial];
    conRec{w}=[conRec{w};S_s2{w}(1) == S_s1(end)];

    for t = 1:n
        total_dis2 = sum(Pdis2_f{w}(t,:)) * delta_t;
        for f = 1:num_f
            a = dt/(C_zone(f)*R_zone(f));
            b = dt/C_zone(f);
            Qstor2 = Pdis2_f{w}(t,f)*1000;
            conRec{w} = [conRec{w};T_s2{w}(t+1,f) == T_s2{w}(t,f) + a*(T_out_s{w}(t)-T_s2{w}(t,f)) ...
                             + b*(Q_s2{w}(t,f) + Q_int_s{w}(t) + Qstor2)];
            conRec{w} = [conRec{w};   0 <= Pdis2_f{w}(t,f) <= P_floor_max3];
            
        end
        conRec{w} = [conRec{w};S_s2{w}(t+1) == S_s2{w}(t) + eta_c3*Pch2{w}(t)*delta_t - total_dis2/eta_d3];
        conRec{w} = [conRec{w};total_dis2 <= S_s2{w}(t)];
    end

    %conRec{w} = [conRec{w};T2{w} + slk2{w} >= T_min, T2{w} <= T_max, slk2{w} >= 0];
    conRec{w} = [conRec{w};T_s2{w}(2:end,:) + slk2{w}(2:end,:) >= T_min, T_s2{w}(2:end,:) <= T_max,0 <= slk2{w} <= (T_max - T_min)];
    conRec{w} = [conRec{w}; 0 <= S_s2{w} <= S_max3, 0 <= Q_s2{w} <= Q_max_3, 0 <= Pch2{w} <= P_charge_max3];

    for t=1:n
        conRec{w} = [conRec{w}; Pch2{w}(t)*delta_t <= S_max3 - S_s2{w}(t)];
    end


    Pel2 = (sum(Q_s2{w}(1:n,:),2)/(COP*1000)) + Pch2{w}(1:n);

    conRec{w} = [conRec{w};
        Pel2 <= Pel1 + 1e-6;
        %r{w} >= 0; 
        sshort{w} >= 0; %shortfall limits, cannot be negative 
        %r{w} <= B*(Pel1 - Pel2); % difference of the two stage Power is Commited as reserve in Stage 2 after aggregating
        %r{w} +
        sshort{w} >= Res_RA-B*(Pel1 - Pel2)];
end

%% Objective with TCVaR
conRA = [];%constraints of Risk aversion 
alpha = 0.8; % considering there will be 20% of worst cases 
z = sdpvar(n,1); % VaR threshold
TCVaR_obj = 0;

for t = 1:n
    % accumulate weighted nu across scenarios
    weighted_tail = 0;
    for w = 1:Ns
        % Hourly cost in scenario w
        E_hvac_t = sum(Q_s2{w}(t,:))*dt / (3.6e6 * COP);
        E_ch_t   = Pch2{w}(t)*delta_t;
        E_tot_t  = B * (E_hvac_t + E_ch_t);

        cost_energy_t  = E_tot_t * Price_s{w}(t);
        cost_penalty_t = pen_short * sshort{w}(t) * delta_t / 1000;
        scenario_cost_t = cost_energy_t + cost_penalty_t;

        % CVaR constraints per hour
        conRA = [conRA;
            nu{w}(t) >= scenario_cost_t - z(t);
            nu{w}(t) >= 0];
        weighted_tail = weighted_tail + pi_s(w) * nu{w}(t);
    end
    TCVaR_obj = TCVaR_obj + z(t) + (1/(1-alpha)) * weighted_tail;
end

% Add slack and subtract revenue
TCVaR_obj = TCVaR_obj - cap_price* delta_t* sum(Res_RA) / 1000;
%TCVaR_obj = TCVaR_obj + SlackPenalty * (sum(slk1(:)) + sum(cellfun(@(s) sum(s(:)), slk2)));
sum_slk2 = 0; for w=1:Ns, sum_slk2 = sum_slk2 + sum(slk2{w}(:)); end
TCVaR_obj = TCVaR_obj + SlackPenalty * (sum(slk1(:)) + sum_slk2);

%% SOLVE -- 2 stage Stochastic Optimisation model with Risk avaersion TCVaR
conAll = [conStg1; conRA];
for w = 1:Ns
    conAll = [conAll; conRec{w}];
end

ops_3t = sdpsettings('solver','gurobi','verbose',1, ...
  'gurobi.MIPGap',       0.005, ...    % 0.1% -> 0.5% often 2x faster, same result quality here
  'gurobi.TimeLimit',    3600,  ...
  'gurobi.MIPFocus',     1,     ...    % focus on bound
  'gurobi.Presolve',     2,     ...
  'gurobi.Heuristics',   0.1,   ...    % reduce a bit to save time
  'gurobi.Cuts',         2,     ...
  'gurobi.Threads',      max(1, feature('numcores')-1), ... % leave 1 core free
  'gurobi.Aggregate',    1, ...
  'gurobi.PreSparsify',  1, ...
  'gurobi.Symmetry',     2);
ops_3t.gurobi.NodefileStart = 0.5;
diagnostics3 = optimize(conAll, TCVaR_obj, ops_3t);
solver_time = diagnostics3.solvertime
if diagnostics3.problem ~= 0
    disp('[ERROR] Optimization failed:')
    disp(diagnostics3.info)
else
    fprintf('\n T-CVaR Two-Stage Optimization SUCCESS! You did it SIVA ! Case 3 with CVaR is done. \n');
    R_opt = value(Res_RA);
    fprintf('Max committed reserve: %.2f kW\n', max(R_opt));
    fprintf('Avg committed reserve: %.2f kW\n', mean(R_opt));
end

%save("Case3_TCVAR_Reserve.mat");

% if diagnostics.problem == 0
%    % Stage 1
%     T1v   = value(T1);            % (n+1) x num_f
%     S1v   = value(S1);            % (n+1) x 1
%     Pch1v = value(Pch1);          % (n+1) x 1
%     Q1v   = value(Q1);            % (n+1) x num_f
%     Pel1v = (sum(Q1v(1:n,:),2)/(COP*1000)) + Pch1v(1:n);  % kW
% 
%     % Stage 2 (mid scenario)
%     T2v_mid   = value(T2{mid});
%     S2v_mid   = value(S2{mid});
%     Pch2v_mid = value(Pch2{mid});
%     Q2v_mid   = value(Q2{mid});
%     Pel2v_mid = (sum(Q2v_mid(1:n,:),2)/(COP*1000)) + Pch2v_mid(1:n);
% 
%     % Other
%     R_opt   = value(Res_RA);
%     Price_v = Price(:);
%     t_h     = (0:n) * delta_t;
%     t_h_n   = (1:n) * delta_t;
%     [~, num_f_detect] = size(T2v_mid);
%     f_idx   = unique([1, max(1, round(num_f_detect/2)), num_f_detect]); % ground/middle/top
% 
%     save('Case3_basic.mat', ...
%          't_h','t_h_n','R_opt','Price_v','S2v_mid','Pel2v_mid', ...
%          'T2v_mid','f_idx','T_min','T_max');
% end

if diagnostics3.problem == 0
    mid = ceil(Ns/2);
    % ---- Stage 1 (per-building) ----
    T1v   = value(T_s1);                        % (n+1) x num_f
    S1v   = value(S_s1);                        % (n+1) x 1
    Pch1v = value(Pch1);                      % (n+1) x 1
    Q1v   = value(Q_s1);                        % (n+1) x num_f
    Pel1v = (sum(Q1v(1:n,:),2)/(COP*1000)) + Pch1v(1:n);   % kW

    % ---- Stage 2 (per scenario, per-building) ----
    Pel2_all = zeros(n, Ns);                  % kW
    S2_all   = zeros(n+1, Ns);                % kWh
    sshort_all = zeros(n, Ns);                % kW shortfall-equivalent (aggregated)
    for w = 1:Ns
        S2w   = value(S_s2{w});
        Pchw  = value(Pch2{w});
        Q2w   = value(Q_s2{w});
        Pel2w = (sum(Q2w(1:n,:),2)/(COP*1000)) + Pchw(1:n); % kW

        S2_all(:,w)   = S2w;
        Pel2_all(:,w) = Pel2w;
        sshort_all(:,w) = value(sshort{w});
    end

    % ---- Prices for each scenario (n x Ns) ----
    Price_all = zeros(n, Ns);
    for w = 1:Ns
        Price_all(:,w) = Price_s{w}(1:n);
    end

    % ---- Other items ----
    R_opt   = value(Res_RA);                  % kW (aggregate commitment)
    t_h     = (0:n) * delta_t;                % hours, states
    t_h_n   = (1:n) * delta_t;                % hours, decisions

    % (optional) ground/middle/top indices if you ever need temps later
    [~, num_f_detect] = size(T1v);
    f_idx = unique([1, max(1, round(num_f_detect/2)), num_f_detect]);
    % 
    % save('Case3_TCVaR_3600.mat', ...
    %     'n','Ns','pi_s','delta_t','B','cap_price','pen_short', ...
    %     't_h','t_h_n','R_opt', ...
    %     'S1v','Pel1v', ...
    %     'S2_all','Pel2_all','Price_all','sshort_all', ...
    %     'T_min','T_max','f_idx');
    % fprintf('Saved all results for plotting as Case3_dump.mat\n');
end

%% summarising the optimisation 

if diagnostics3.problem == 0
    %% 1) Electricity & Thermal-power aggregates ------------------------
    %  NOTE:  Pel1v is per-building; multiply by B for the whole pool
    Total_electricity_kWh = sum(Pel1v) * delta_t * B;        % [kWh]
    Avg_electric_kW  = mean(Pel1v) * B;                 % [kW_e] (mean)
    
    Q_th_per_bldg_kW = sum(Q1v(1:n,:),2) / 1000;        % [kW_th] per bldg
    Avg_thermal_kWth = mean(Q_th_per_bldg_kW) * B;      % [kW_th] (mean)
    Peak_thermal_kWth = max(Q_th_per_bldg_kW)  * B;      % [kW_th] (peak)
    
    %% 2) Total electricity cost ---------------------------------------
    Total_cost_EUR = sum(Pel1v .* Price(1:n) * delta_t * B); % [€]
    
    %% 3) Reserve statistics -------------------------------------------
    Avg_committed_reserve  = mean(R_opt);   % already pooled [kW]
    Peak_committed_reserve = max(R_opt);    % [kW]
    
    %% 4) Indices of first max-reserve and next zero-reserve ------------
    [~, idx_maxR]  = max(R_opt);                          % first peak
    idx_zero_after = find(R_opt(idx_maxR+1:end)==0,1);    % next zero
    idx_zeroR  = (isempty(idx_zero_after))* n  + ( ~isempty(idx_zero_after)) .* (idx_maxR + idx_zero_after);
                       
                       
                   
    %% 5) Snapshots at those indices -----------------------------------
    %  (values per-building for Pel & Q_th; SoC is system-level)
    snapshot = struct();
    
    snapshot.time_h_maxR  = t_h_n(idx_maxR);     % [h]
    snapshot.time_h_zeroR = t_h_n(idx_zeroR);    % [h]
    
    snapshot.R_max  = R_opt(idx_maxR);     % [kW]
    snapshot.R_zero = R_opt(idx_zeroR);    % =0 [kW]
    
    snapshot.Pel_maxR  = Pel1v(idx_maxR);     % [kW] per bldg
    snapshot.Pel_zeroR = Pel1v(idx_zeroR);    % [kW] per bldg
    
    snapshot.SOC_maxR = S1v(idx_maxR);       % [kWh]
    snapshot.SOC_zeroR = S1v(idx_zeroR);      % [kWh]
    
    snapshot.Qth_maxR = Q_th_per_bldg_kW(idx_maxR); % [kW_th] per bldg
    snapshot.Qth_zeroR = Q_th_per_bldg_kW(idx_zeroR);% [kW_th] per bldg
    
    snapshot.Price_maxR = Price(idx_maxR);     % [€/kWh]
    snapshot.Price_zeroR = Price(idx_zeroR);    % [€/kWh]
    
    %% 6) Print concise report -----------------------------------------
    fprintf('\n================ CASE 3 — Key Metrics ================\n');
    fprintf('Total electricity          : %8.2f kWh\n',  Total_electricity_kWh);
    fprintf('Total cost                 : €%8.2f\n',     Total_cost_EUR);
    fprintf('Avg electric power         : %8.2f kW_e\n', Avg_electric_kW);
    fprintf('Avg thermal power          : %8.2f kW_th\n',Avg_thermal_kWth);
    fprintf('Peak thermal power         : %8.2f kW_th\n',Peak_thermal_kWth);
    fprintf('Avg committed reserve      : %8.2f kW\n',   Avg_committed_reserve);
    fprintf('Peak committed reserve     : %8.2f kW\n',   Peak_committed_reserve);
    fprintf('--- Snapshot @ max-R (t=%.1fh) -----------------------\n', ...
                                                   snapshot.time_h_maxR);
    fprintf('   Pel=%6.2f kW  SoC=%6.2f kWh  Q_th=%6.2f kW_th  Price=€%.3f/kWh\n', ...
            snapshot.Pel_maxR, snapshot.SOC_maxR, ...
            snapshot.Qth_maxR, snapshot.Price_maxR);
    fprintf('--- Snapshot @ next zero-R (t=%.1fh) -----------------\n', ...
                                                   snapshot.time_h_zeroR);
    fprintf('   Pel=%6.2f kW  SoC=%6.2f kWh  Q_th=%6.2f kW_th  Price=€%.3f/kWh\n', ...
            snapshot.Pel_zeroR, snapshot.SOC_zeroR, ...
            snapshot.Qth_zeroR, snapshot.Price_zeroR);
    fprintf('=======================================================\n');
    
    %% 7) (Optional) quick plots with vertical markers -----------------
    %  Comment out if you don’t need the figures.
    figure('Color','w'); tiledlayout(3,1,'TileSpacing','compact');
    
    nexttile;  plot(t_h_n, Pel1v*B); hold on;
               xline(snapshot.time_h_maxR,'r--'); xline(snapshot.time_h_zeroR,'g--');
               ylabel('P_{el,total} [kW]'); grid on; title('Electric power');
               
    nexttile;  plot(t_h, S1v); hold on;
               xline(snapshot.time_h_maxR,'r--'); xline(snapshot.time_h_zeroR,'g--');
               ylabel('SoC [kWh]'); grid on; title('Storage state');
               
    nexttile;  plot(t_h_n, R_opt); hold on;
               xline(snapshot.time_h_maxR,'r--'); xline(snapshot.time_h_zeroR,'g--');
               ylabel('Reserve [kW]'); xlabel('Time [h]'); grid on;
               title('Committed reserve');

               % --- sanity: portfolio → per-building comparison
perBldg  = @(x) x / B;          % helper
fprintf('\nPer-building totals (stochastic vs deterministic)…\n');
fprintf('  Electricity : %.2f vs %.2f kWh\n', perBldg(Total_electricity_kWh), 99656.9);
fprintf('  Cost        : €%.2f vs €%.2f\n', perBldg(Total_cost_EUR), 4617.22);
fprintf('  Avg P_el    : %.2f vs %.2f kW\n', perBldg(Avg_electric_kW), 69.21);
fprintf('  Avg P_th    : %.2f vs %.2f kW\n', perBldg(Avg_thermal_kWth), 173.02);

end

%% ------
%% ---------- Diagnostic: numeric (no sdpvar) --------------------------
if diagnostics3.problem == 0
    % 1) Expected energy-only cost [€]  – use Pel2_all that is already numeric
    Exp_EnergyCost = 0;
    for w = 1:Ns
        E_kWh_w = Pel2_all(:,w) * delta_t * B;         % kWh, pooled
        Exp_EnergyCost = Exp_EnergyCost + ...
                         pi_s(w) * sum(E_kWh_w .* Price_all(:,w));
    end

    % 2) Capacity-market revenue [€]
    CapRevenue = cap_price * delta_t * sum(R_opt) / 1000;   % kW·h→MWh

    % 3) Tail-risk term in the CVaR objective
    z_num  = value(z);                              % (n×1 double)
    nu_num = cellfun(@value, nu, 'UniformOutput',false);
    TailRisk = sum(z_num) + (1/(1-alpha)) * ...
               sum( cellfun(@sum, nu_num) .* pi_s' );

    % 4) Print
    fprintf('\n*** Diagnostic (numeric) ***\n');
    fprintf(' Expected energy-only cost : €%.2f\n', Exp_EnergyCost);
    fprintf(' Capacity revenue (earned) : €%.2f\n', CapRevenue);
    fprintf(' Tail-risk term (CVaR)     : %.2e\n', TailRisk);
end
save('Case3_TCVaR_new.mat', 'n','Ns','pi_s','delta_t','B','cap_price','pen_short','t_h','t_h_n','R_opt','S1v','Pel1v','S2_all','Pel2_all','Price_all','sshort_all','T_min','T_max','f_idx');

